using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace @interface
{

    /* интерфейсы.

    класс определяет сущность, т.е. отвечает на вопрос "кто я".
    интерфейс определяет действие или набор действий, выражаемых глаголами, т.е. отвечает на вопрос "что я могу делать".
    например интерфейс IComparable говорит лишь о том, что объекты его реализующие - можно сравнивать.
    он ничего не говорит о сущности самих объектов, о их типах и т.д.
    тогда как абстрактный класс Control говорит, что объект является элементом управления.

    интерфейсы описывают только поведение сущности (что может делать объект, реализующий интерфейс, через свои методы,
    какие он может генерировать события, и через какие свойства он может рассказывать о себе.

    классы же описывают как свое поведение, так и внутреннее состояние (чему равно в каждый отрезок времени каждое
    из полей класса.

    интерфес содержит описание свойств и методов, реализацию которых обязуется осуществить класс-наследник.

    экземпляр интерфейса создать нельзя.

    любой класс может наследовать любое количество интерфейсов.
    но при этом он должен реализовать все его методы.


    Абстрактные классы. В отличие от обычных классов, экземпляры их не могут быть созданы. Вот и все отличия. Поэтому абстрактные классы не могут содержать конструкторов. В остальном - отличий нет.

    Интерфейсы (в отличие от классов, как обычных. так и абстрактных) не могут содержать:
    - полей
    - констант
    - перегрузок операторов приведения типа
    - перегрузок арифметических операторов
    - вложенных типов

    Интерфейсы описывают только поведение сущности (что может делать объект, реализующий интерфейс, через свои методы, какие он может генерить события и через какие свойства он может рассказывать о себе) smile
    Классы же описывают как свое поведение, так и внутреннее состояние (чему равно в каждый отрезок времени каждое из полей класса)

    И еще: можно реализовать множественное наследование интерфейсов, но нельзя реализовать множественное наследование от абстрактных классов. 

    */

    public interface IManage
    {
        int Salary { get; set; }
        void Plan();
        void Organize();
        void Motivate();
        void Control();
    }

    public class Human
    {
        protected string name;
        protected string lastname;
        protected int age;
    }

    public class Manager : Human, IManage
    {
        int salary;
        public int Salary
        {
            get { return salary; }
            set { salary = value; }
        }

        public void Plan() { }
        public void Organize() { }
        public void Motivate() { }
        public void Control() { }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Manager Misha = new Manager();
            Misha.Motivate();
        }
    }
}
